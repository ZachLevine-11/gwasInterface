
##' Handle external browser options for the shiny.
##'
##'
##' @import shiny
##' @export
##' @param openinBrowser a logical indicating whether the shiny app should be opened in the browser or not
browserManager <- function(openinBrowser){
  if (openinBrowser){
    ##Use get to circumvent the global binding errors.
    options(shiny.launch.browser = get(".rs.invokeShinyWindowExternal", envir = as.environment("tools:rstudio")))
  }
  else{
    options(shiny.launch.browser = get(".rs.invokeShinyWindowViewer", envir = as.environment("tools:rstudio")))
  }
}

parameter.files <- c("CI_base.csv","CI_updApr1.csv","ICU1.csv", "ICU_diffs.csv", "PHAC.csv")
default.parameter.file <- "ICU1.csv"
default.start.date <- "2020-01-01"
default.dropstates <- c("t","S","E","I","X")
timeunitParams <- c("sigma", "gamma_a", "gamma_m", "gamma_s", "gamma_p", "rho")
beta0 <- 1

##' Run the McMasterPandemic Shiny
##'
##' run_shiny() is an example of a single-file Shiny app in that it defines a UI object and a server method to handle that object. A benefit is that Roxygen import tags only need to be called once to become available to the entire shiny, and it's easy to run the shiny as well. After both the ui object and server function are defined, browserManager is called, which sets the viewing environment that the Shiny runs in. Anywhere with a tag$html call is either a CSS or HTML tag to change certain visual aspects of the shiny.  In addition, many ui elements are rendered in the server function and passed to ui with renderUI. RenderHTML is another wrapper for this as well. This lets us make UI elements which depend on input from the UI itself.
##'
##' @param useBrowser A logical indicating whether to run the Shiny in the default browser or in a seperate window generated by RStudio.
##' @param usingOnline A logical indicating whether the app is being run on shinyapps.io or not.
##' @import shiny
##' @return NULL
##' @export
run_shiny <- function(useBrowser = TRUE, usingOnline = FALSE) {
  ## The ui (user interface) is what the user is shown when running
  ## the shiny.  The ui also gathers input that is the passed to the
  ## server (e.g., filling in boxes or sliders).
  ui <- fluidPage(theme = shinythemes::shinytheme("flatly"),
                  ##Set the title panel to be Heritage Maroon.
                  h1(id = "heading", "Segal10KGwas"),
                  ##Colour the top and bottom of the page appropriately.
                  tags$style(HTML("#heading {background-color: #7A003C; color: white !important;}")),
                  tags$style(HTML("#sourcelink {background-color: #7A003C; color: white !important;}")),
                  #Change the colours of text on the tab selectors to be blue.
                  tags$style(HTML("
                                  .tabbable > .nav > li > a[data-value='plotaes'] {color: blue}
                                  .tabbable > .nav > li > a[data-value='tcr'] {color: blue}
                                  .tabbable > .nav > li > a[data-value='parametersPanel'] {color: blue}
                                  .tabbable > .nav > li > a[data-value='procObsErr'] {color: blue}
                                  ")),
                  ##Bold the explanation title for the error entry tab.
                  tags$style(HTML("#explanationTitle {font-weight: bold;}")),
                  ##Set the colour of the sidebar panel to be Heritage Gold.
                  tags$head(tags$style(HTML('#sidebar {background-color: #FDBF57;}'))),
                  ##Bold the checkbutton panel title.
                  tags$style(HTML("#checkButtonTitle {font-weight: bold;}")),
                  ##Bold the summary table title.
                  tags$style(HTML("#summaryTitle {font-weight: bold;}")),
                  ##Set the background colour to be a lighter and faded Heritage Grey (original one is too dark).
                  shinyWidgets::setBackgroundColor(color = "#e6ebed"),
                  sidebarLayout(
                    sidebarPanel(id = "sidebar", width = 4,
                                 fluidRow(
                                   selectInput("fn",
                                               label = "Sample parameter file:",
                                               choices = parameter.files, selected = default.parameter.file),
                                   downloadButton("downloadData", "Download sample parameter file", class = "dbutton"),                                 ),
                                 fluidRow(
                                   textOutput("checkButtonTitle"),
                                   uiOutput("plotTogglePanel")
                                 ),
                                 fluidRow(
                                   dateInput(inputId = "sd",
                                             label = "Start Date",
                                             value = default.start.date,
                                             min = "2020-01-01",
                                             max = "2030-11-31"),
                                   uiOutput("endDate")),
                                 fluidRow(
                                   column(4,
                                          textOutput("summaryTitle"),
                                          tableOutput("summary")
                                   )
                                 ),
                                 ## Only show the selector to input parameters if that's selected.
                                 uiOutput("maintabPanel"),
                                 ##Colour the checkboxes to match the curves in the plot.
                                 ##Use the below object to call the HTML tags within the server function.
                                 htmlOutput("colourManager")),
                    mainPanel(
                      fluidRow(
                        uiOutput("plotColumn"),
                        br())
                    )
                  ),
                  uiOutput("sourcelink")
                  )

  #Everything else.
  server <- function(input, output, session){
    ## non-standard eval; circumvent 'no visible binding' check
    x <- Date <- Symbol <- Relative_value <- Rt <- NULL
    output$plotColumn <- renderUI({
      library(cars)
      plot(cars$speed, cars$dist)
    })
    ##Render the tab panel server-side to force tab changes the way we'd like, and give us the load-edit functionality we're after.
    output$maintabPanel <- renderUI({
      tabsetPanel(
        ##Use this to force the tab to change.
        id = "tabs",
        ##The parameters panel needs to be the default selected panel. This is so it Shiny can render the panel first. The input slots aren't created until the panel is created.
        ##So keep the default to be the parametersPanel to avoid ugly errors.
        selected = "plotaes",
        tabPanel(
          title = "Time-varying transmission rates",
          value = "tcr",
          textOutput("trmsg"),
          checkboxInput("useVarying", label = "Simulate with time-varying transmission rates", value = FALSE),
          conditionalPanel(condition = "input.useVarying",
            br(),
            br(),
            ##Default time point is two months into the simulation.
            textInput("timeParsDates", label = "Dates of changes, separated by commas", value = paste(lubridate::ymd(input$sd) + months(2), lubridate::ymd(input$sd) + months(4), lubridate::ymd(input$sd) + months(4), sep = ",")),
            textInput("timeParsSymbols", label = "Parameter to change on each date", value = "beta0, beta0, alpha"),
            textInput("timeParsRelativeValues", label = "Relative change on each date", value = "0.5, 0.75, 1.1"),
          #  plotOutput("paramsPlot")
          )
        ),
        tabPanel(
          title = "Plot aesthetics",
          value = "plotaes",
          sliderInput("Globalsize", "Text size:",
                      min = 5, max = 45,
                      step = 0.25,
                      value = 20),
          sliderInput("lineThickness", "Line thickness:",
                      min = 0, max = 10,
                      step = 0.25,
                      value = 3),
          radioButtons(inputId = "scale",
                       label = "Scaling options",
                       choices = c("none",
                                   "log y scale",
                                   "sqrt y scale"),
                       selected = "none"),
          checkboxInput(inputId = "automaticSize",
                        label = ("Show sliders for individual text element sizes"),
                        value = 0),
          conditionalPanel(condition = "input.automaticSize",
                           sliderInput("titleSize", "Title size:",
                                       min = 0, max = 25,
                                       value = 20),
                           sliderInput("XtextSize", "X axis title size:",
                                       min = 0, max = 25,
                                       value = 10),
                           sliderInput("YtextSize", "Y axis title size:",
                                       min = 0, max = 25,
                                       value = 10)
          )),
        tabPanel(
          title = "Simulation Parameters",
          value = "parametersPanel",
          checkboxInput(inputId = "showAll",
                        label = ("Show parameter sliders"),
                        value = FALSE),
          conditionalPanel(condition = "input.showAll"
                           ##Using names to avoid factors getting passed as inputs to textInput_param.
                                ##Since we can set R0, we don't want to have the option to change beta0.
                                )
        )
      )})

    ##Handle downloads for the sample template csv file.
    ##The file is an empty version of ICU1.csv so it scales as more parameters are added.
    output$downloadData <- downloadHandler(
      filename = function(){return("sampleparams.csv")},
      content = function(file) {
        basicTemplate <- read_in_csv()
        ##Default the values column.
        basicTemplate$Value <- read_params("PHAC.csv")
        write.csv(basicTemplate, file, row.names = FALSE)
      }
    )

    output$summaryTitle <- renderText({"Summary characteristics"})
    output$explanationTitle <- renderText({"Explanation"})
    output$errorExplanations <- renderText({"Use these options to simulate noise in the data. The observation error parameter is the dispersion parameter for a negative binomial distribution. A suitable value could be 200.
      The process dispersion parameter adds gamma white noise to the event rates by pulling from a multinomial distribution. A reasonable value for process dispersion is 0.5"})
    output$checkButtonTitle <- renderText({"Curves to display"})
    ##EndDate is the name of the ui object, "ed" is the name of the input slot to store the end date in.
    ##We make this reactive so we can use the input start date as the minimum value for the end date.
    output$sourcelink <- renderUI({tagList(
      "McMaster Pandemic source code available at ",
      a("https://github.com/bbolker/McMasterPandemic", href = "https://github.com/bbolker/McMasterPandemic"),
      "                                Shiny interface to McMaster Pandemic by Zachary Levine."
    )})
  }
  if (usingOnline == FALSE){
    ##Set the viewing options first.
    ##Run the shiny app. the default value of launch.browser looks for the option set by browserManager.
    shiny::runApp(appDir = shinyApp("ui" = ui, "server" = server), launch.browser = getOption("shiny.launch.browser", interactive()))
    browserManager(useBrowser)
  }
  else{
    shinyApp(ui, server)
    }
}
